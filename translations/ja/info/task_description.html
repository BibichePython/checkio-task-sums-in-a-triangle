<p>
    我らがロボ・トリオは来たる宝探しの旅に備えて訓練を積む必要があります。
	スティーブンはピラミッドの二次元モデルを作成しました。
	これにより、ロボの金の探索訓練を行うことができます。
	ロボはピラミッドの頂上をスタート地点とし、各々の部屋で金を集めます。
	ピラミッドを降りるたびに、右の部屋に行くか、左の部屋に行くかの選択をします。
	金の獲得量を最適化するため、スティーブンは一度に最大でどのくらいの量の金を獲得できるか知る必要があります。
</p>
<p>
    タプルのタプルを考えてみましょう。最初のタプルは一つの整数を持ち、次のタプルに行くと整数が一つ増えます。
    このようなタプルは三角形に見えるでしょう。
    スティーブンが最大の利益を得られるようなルートを探索するプログラムを書きましょう。
    全てのルートは左下に降りるか、右下に降りるかを繰り返します。
</p>

<p>
    <strong>ヒント:</strong>
    左下に降りるときはインデックスは変わらず、右下に降りるときは一つ大きいインデックスになると考えましょう。
    もし再帰関数を使うのであれば注意しましょう。
</p>
<p class="for_info_only" style="text-align: center">
    <img title="sum-in-triangles"
         src="{{ MEDIA }}sum-in-triangles.png"
         alt="sum-in-triangles"
         width="500px"/>
</p>
<p class="for_editor_only" style="text-align: center">
    <img title="sum-in-triangles"
         src="{{ MEDIA }}sum-in-triangles.png"
         alt="sum-in-triangles"
         width="380px"/>
</p>

<p><strong>入力: </strong>タプルのタプル形式のピラミッド。各々のタプルは整数値から成ります。</p>

<p><strong>出力: </strong>合計で得られる最大の整数値。</p>

<div class="for_info_only">
    <p><strong>例:</strong></p>
<pre class="brush: python">count_gold((
    (1,),
    (2, 3),
    (3, 3, 1),
    (3, 1, 5, 4),
    (3, 1, 3, 1, 3),
    (2, 2, 2, 2, 2, 2),
    (5, 6, 4, 5, 6, 4, 3)
)) == 23
count_gold((
    (1,),
    (2, 1),
    (1, 2, 1),
    (1, 2, 1, 1),
    (1, 2, 1, 1, 1),
    (1, 2, 1, 1, 1, 1),
    (1, 2, 1, 1, 1, 1, 9)
)) == 15
count_gold((
    (9,),
    (2, 2),
    (3, 3, 3),
    (4, 4, 4, 4)
)) == 18
</pre>
</div>

<p class="for_info_only">
    <strong>どう使われるか: </strong>
    これは動的プログラミングの例に使われる古典的な問題です。
    多くの最適化問題に応用できる基本的なコンセプトです。
</p>

<p>
    <strong>条件: </strong>
    0 &lt; len(pyramid) &le; 20<br>
    all(all(0 &lt; x &lt; 10 for x in row) for row in pyramid)
</p>
